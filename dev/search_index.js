var documenterSearchIndex = {"docs":
[{"location":"interface/#API-documentation-1","page":"API","title":"API documentation","text":"","category":"section"},{"location":"interface/#","page":"API","title":"API","text":"rotate","category":"page"},{"location":"interface/#QuaternionIntegrator.rotate","page":"API","title":"QuaternionIntegrator.rotate","text":"rotate(q::Quaternion, v::Vector)\n\nApply orientation quaternion q to rotate vector v, return rotated vector.\n\nAn object's orientation quaternion rotates vectors from the body-fixed coordinates to world coordinates. For the opposite rotation, call rotate(inv(q), v).\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"API","title":"API","text":"orientation","category":"page"},{"location":"interface/#QuaternionIntegrator.orientation","page":"API","title":"QuaternionIntegrator.orientation","text":"orientation(v::Vector, angle::Real)\n\nReturn an orientation quaternion with the given axis v and rotation angle.\n\nThe vector v is assumed to be normalized to unit length.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"API","title":"API","text":"integrate","category":"page"},{"location":"interface/#QuaternionIntegrator.integrate","page":"API","title":"QuaternionIntegrator.integrate","text":"integrate(q0::Quaternion, w0::Vector, Ib::Matrix, dt::Real, torque::Function)\n\nIntegrate a rotational state ahead by one time step.\n\nq0, current orientation quaternion.\nw0, current angular velocity.\nIb, inertial tensor of the object in body coordinates.\ndt, length of time step.\ntorque, a function that returns a torque vector given an orientation. \n\nReturns (q1, w1), the orientation and angular velocity at the end of the time step.\n\n\n\n\n\nintegrate(q0::Quaternion, w0::Vector, Ib::Matrix, dt::Real, torque::Function, N::Integer)\n\nIntegrate a rotational state ahead by N time steps.\n\nReturns (q1, w1), the orientation and angular velocity after N integration steps.\n\n\n\n\n\n","category":"function"},{"location":"algorithm/#The-algorithm-1","page":"The algorithm","title":"The algorithm","text":"","category":"section"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The purpose of the algorithm is to take the current orientation q_0 and angular velocity omega_0 and produce the orientation q_1 and angular velocity omega_1 after a time step Delta t.","category":"page"},{"location":"algorithm/#Orientation-and-coordinate-frames-1","page":"The algorithm","title":"Orientation and coordinate frames","text":"","category":"section"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"An object's orientation is a rotation between two coordinate frames: world coordinates and body coordinates. The body frame is fixed to the object and rotates with it relative to the world coordinates.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The orientation of the object is represented as a standard rotation quaternion: given a unit vector along a rotational axis mathbf v and an angle around that axis theta, the quaternion is","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"q = left(cos fractheta2 sin fractheta2 mathbf v right)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nQuaternions are represented in this text as a pair (a mathbf v) of a real number and a 3-dimensional real-valued vector. Other equivalent representations exist but this one is the most useful here.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The orientation quaternion is used to transform vectors from body coordinates to world coordinates and vice versa. Given a vector mathbf v_b in body coordinates, and the orientation q, the rotation to world coordinates coordinates is the operation mathbf v = q mathbf v_b q^-1. The rotation from world coordinates to body coordinates is simply the inverse, mathbf v_b = q^-1 mathbf v q.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nWe denote the rotation of a vector mathbf v by a quaternion with q mathbf v q^-1. In practice, this operation involves constructing a new quaternion (0 mathbf v), performing the quaternion multiplication and extracting the vector part of the resulting quaternion.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nWe denote vectors in the body coordinate frame with the subscript b and in the world coordinate with no subsript.","category":"page"},{"location":"algorithm/#Integration-step-1","page":"The algorithm","title":"Integration step","text":"","category":"section"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The algorithm is from F. Zhao and B. G. M. van Wachem (2013) A novel Quaternion integration approach for describing the behaviour of non-spherical particles, Acta Mech 224, 3091â€“3109. For a full derivation and more detail, see the paper.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"We begin with the initial orientation q_0, initial angular velocity vector mathbf omega_0, which is the momentary rate of change of the orientation. We also have a torque function T(q) which taken an orientation quaternion and returns a torque vector in world coordinates, as well as the inertial tensor of the object, given in the body frame, I_b.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nWe denote quantities at the beginning of the timestep with the subscript 0, at the end of the timestep with subscript 1. In the algorithm, also midpoint and quarter-point values are used and these are denoted with frac12 and frac14","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"First we transform the angular velocity vector to body coordinates:","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"mathbf omega_b0 = q_0^-1 mathbf omega_0 q","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"We compute the torque in the initial orientation and transform the resulting torque vector to the body frame.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_0 = T(q_0)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_b0 = q_0^-1 mathbf tau_0 q","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The angular acceleration, in the body frame, is computed from the inertia and the torque:","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"dotomega_b0 = I_b^-1 left( tau_b0 - omega_b0 times I_b omega_b0 right)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"Next, we compute angular velocity in the body frame after a quarter timestep and a half timestep.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_bfrac14 = omega_bo + frac12 dotomega_b0 Delta t","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_bfrac12 = omega_b0 + frac14 dotomega_b0 Delta t","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"We rotate the quarter-point angular velocity to the world coordinates and use it to compute a \"prediction\" for the half-point orientation quaternion.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_frac14 = q_0 omega_bfrac14 q_0^-1","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"q_frac12 = left( cos left(frac14 left omega_frac14 right\nDelta t right) sin left( frac14 left omega_frac14 right Delta t\nright) hat omega_frac14 right) q_0","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nThe hat represents a vector normalized to unit length.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"This predicted midpoint orientation is then used to compute a torque and angular acceleration at the midpoint:","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_0 = T(q_frac12)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_bfrac12 = q_0^-1 mathbf tau_frac12 q","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"dotomega_bfrac12 = I_b^-1 left( tau_bfrac12 - omega_bfrac12 times I_b omega_bfrac12 right)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"This midpoint acceleration is then used with the starting orientation to compute the endpoint orientation","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_frac12 = q_frac12 omega_bfrac12 q_frac12^-1","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"q_1 = left( cos left(frac12 left omega_frac12 right\nDelta t right) sin left( frac12 left omega_frac12 right Delta t\nright) hat omega_frac12 right) q_0","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"Finally, the angular acceleration at the midpoint is used to compute the angular velocity at the endpoint.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_b1 = omega_b0 + dotomega_bfrac12 Delta t","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_1 = q_1 omega_b1 q_1^-1","category":"page"},{"location":"#QuaternionIntegrator.jl-1","page":"QuaternionIntegrator","title":"QuaternionIntegrator.jl","text":"","category":"section"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"QuaternionIntergrator.jl is a Julia package that lets you compute the time evolution of an object's rotational state, given its inertial tensor and an external torque function.","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"Based on the algorithm given by F. Zhao and B. G. M. van Wachem (2013) A novel Quaternion integration approach for describing the behaviour of non-spherical particles, Acta Mech 224, 3091â€“3109.","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"The orientation of the object is represented as a standard rotation quaternion: given a unit vector along a rotational axis mathbf v and an angle around that axis theta, the quaternion is","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"q = left(cos fractheta2 sin fractheta2 mathbf v right)","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"This quaternion represents a rotation from body-fixed coordinates to world coordinates.","category":"page"},{"location":"#Quick-start-1","page":"QuaternionIntegrator","title":"Quick start","text":"","category":"section"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"using Quaternions\nusing QuaternionIntegrator\n\n# Constant torque around y axis\ntorque(q) = [0.0, 1.0, 0.0]\n\n# Simplest diagonal inertial tensor\nI = diagm([1.0, 1.0, 1.0])\n\n# Starting orientation (no rotation)\nq0 = Quaternion(1.0, 0.0, 0.0, 0.0)\n\n# Starting angular velocity (not rotating)\nÏ‰0 = [0.0, 0.0, 0.0]\n\n# Integration time step\nâˆ†t = 0.01\n\n# Get orientation and angular velocity after one timestep\nq1, Ï‰1 = integrate(q0, Ï‰0, I, âˆ†t, torque)\n\n# Compute 1000 time steps ahead\nqn, Ï‰n = integrate(q0, Ï‰0, I, âˆ†t, torque, 1000)","category":"page"}]
}
