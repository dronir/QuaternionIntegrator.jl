var documenterSearchIndex = {"docs":
[{"location":"interface/#API-documentation-1","page":"API","title":"API documentation","text":"","category":"section"},{"location":"interface/#","page":"API","title":"API","text":"rotate","category":"page"},{"location":"interface/#QuaternionIntegrator.rotate","page":"API","title":"QuaternionIntegrator.rotate","text":"rotate(q::Quaternion, v::Vector)\n\nApply orientation quaternion q to rotate vector v, return rotated vector.\n\nAn object's orientation quaternion rotates vectors from the body-fixed coordinates to world coordinates. For the opposite rotation, call rotate(inv(q), v).\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"API","title":"API","text":"orientation","category":"page"},{"location":"interface/#QuaternionIntegrator.orientation","page":"API","title":"QuaternionIntegrator.orientation","text":"orientation(v::Vector, angle::Real)\n\nReturn an orientation quaternion with the given axis v and rotation angle.\n\nThe vector v is assumed to be normalized to unit length.\n\n\n\n\n\n","category":"function"},{"location":"interface/#","page":"API","title":"API","text":"integrate","category":"page"},{"location":"interface/#QuaternionIntegrator.integrate","page":"API","title":"QuaternionIntegrator.integrate","text":"integrate(q0::Quaternion, ω0::Vector, Ib::Matrix, ∆t, torque::Function)\n\nIntegrate a rotational state ahead by one time step.\n\nq0, current orientation quaternion.\nω0, current angular velocity (length-3 vector).\nIb, inertial tensor of the object in body coordinates (3×3 matrix).\n∆t, length of time step.\ntorque, a function that returns a (length-3) torque vector given an orientation. \n\nReturns (q1, ω1), the orientation and angular velocity at the end of the time step.\n\nUsing the Unitful package, all inputs can have units, all the mathematics are done with units and the return values will have correct units.\n\nq0 is dimensionless.\nω0 has dimension of 1/time (SI: 1/second)\nIb has dimension mass * length^2 (SI: kilogram * meter^2)\n∆t has dimension of time (SI: second)\ntorque returns a value with dimension of torque (SI: Newton * meter)\n\n\n\n\n\nintegrate(q0::Quaternion, ω0::Vector, Ib::Matrix, ∆t, torque::Function, N::Integer)\n\nIntegrate a rotational state ahead by N time steps.\n\nReturns (q1, ω1), the orientation and angular velocity after N integration steps.\n\n\n\n\n\n","category":"function"},{"location":"algorithm/#The-algorithm-1","page":"The algorithm","title":"The algorithm","text":"","category":"section"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The purpose of the algorithm is to take the current orientation q_0 and angular velocity omega_0 and produce the orientation q_1 and angular velocity omega_1 after a time step Delta t.","category":"page"},{"location":"algorithm/#Orientation-and-coordinate-frames-1","page":"The algorithm","title":"Orientation and coordinate frames","text":"","category":"section"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"An object's orientation is a rotation between two coordinate frames: world coordinates and body coordinates. The body frame is fixed to the object and rotates with it relative to the world coordinates.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The orientation of the object is represented as a standard rotation quaternion: given a unit vector along a rotational axis mathbf v and an angle around that axis theta, the quaternion is","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"q = left(cos fractheta2 sin fractheta2 mathbf v right)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nQuaternions are represented in this text as a pair (a mathbf v) of a real number and a 3-dimensional real-valued vector. Other equivalent representations exist but this one is the most useful here.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The orientation quaternion is used to transform vectors from body coordinates to world coordinates and vice versa. Given a vector mathbf v_b in body coordinates, and the orientation q, the rotation to world coordinates coordinates is the operation mathbf v = q mathbf v_b q^-1. The rotation from world coordinates to body coordinates is simply the inverse, mathbf v_b = q^-1 mathbf v q.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nWe denote the rotation of a vector mathbf v by a quaternion with q mathbf v q^-1. In practice, this operation involves constructing a new quaternion (0 mathbf v), performing the quaternion multiplication and extracting the vector part of the resulting quaternion.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nWe denote vectors in the body coordinate frame with the subscript b and in the world coordinate with no subsript.","category":"page"},{"location":"algorithm/#Integration-step-1","page":"The algorithm","title":"Integration step","text":"","category":"section"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The algorithm is from F. Zhao and B. G. M. van Wachem (2013) A novel Quaternion integration approach for describing the behaviour of non-spherical particles, Acta Mech 224, 3091–3109. For a full derivation and more detail, see the paper.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"We begin with the initial orientation q_0, initial angular velocity vector mathbf omega_0, which is the momentary rate of change of the orientation. We also have a torque function T(q) which taken an orientation quaternion and returns a torque vector in world coordinates, as well as the inertial tensor of the object, given in the body frame, I_b.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nWe denote quantities at the beginning of the timestep with the subscript 0, at the end of the timestep with subscript 1. In the algorithm, also midpoint and quarter-point values are used and these are denoted with frac12 and frac14","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"First we transform the angular velocity vector to body coordinates:","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"mathbf omega_b0 = q_0^-1 mathbf omega_0 q","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"We compute the torque in the initial orientation and transform the resulting torque vector to the body frame.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_0 = T(q_0)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_b0 = q_0^-1 mathbf tau_0 q","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"The angular acceleration, in the body frame, is computed from the inertia and the torque:","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"dotomega_b0 = I_b^-1 left( tau_b0 - omega_b0 times I_b omega_b0 right)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"Next, we compute angular velocity in the body frame after a quarter timestep and a half timestep.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_bfrac14 = omega_bo + frac12 dotomega_b0 Delta t","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_bfrac12 = omega_b0 + frac14 dotomega_b0 Delta t","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"We rotate the quarter-point angular velocity to the world coordinates and use it to compute a \"prediction\" for the half-point orientation quaternion.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_frac14 = q_0 omega_bfrac14 q_0^-1","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"q_frac12 = left( cos left( left omega_frac14 right fracDelta t4\nright) sin left( left omega_frac14 right fracDelta t4 right) hat\nomega_frac14 right) q_0","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"note: Note\nThe hat represents a vector normalized to unit length.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"This predicted midpoint orientation is then used to compute a torque and angular acceleration at the midpoint:","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_0 = T(q_frac12)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"tau_bfrac12 = q_0^-1 mathbf tau_frac12 q","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"dotomega_bfrac12 = I_b^-1 left( tau_bfrac12 - omega_bfrac12 times I_b omega_bfrac12 right)","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"This midpoint acceleration is then used with the starting orientation to compute the endpoint orientation","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_frac12 = q_frac12 omega_bfrac12 q_frac12^-1","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"q_1 = left( cos left( left omega_frac12 right fracDelta t2 right) sin\nleft( left omega_frac12 right fracDelta t2 right) hat omega_frac12\nright) q_0","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"Finally, the angular acceleration at the midpoint is used to compute the angular velocity at the endpoint.","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_b1 = omega_b0 + dotomega_bfrac12 Delta t","category":"page"},{"location":"algorithm/#","page":"The algorithm","title":"The algorithm","text":"omega_1 = q_1 omega_b1 q_1^-1","category":"page"},{"location":"#QuaternionIntegrator.jl-1","page":"QuaternionIntegrator","title":"QuaternionIntegrator.jl","text":"","category":"section"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"QuaternionIntergrator.jl is a Julia package that lets you compute the time evolution of an object's rotational state, given its inertial tensor and an external torque function.","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"Based on the algorithm given by F. Zhao and B. G. M. van Wachem (2013) A novel Quaternion integration approach for describing the behaviour of non-spherical particles, Acta Mech 224, 3091–3109.","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"The orientation of the object is represented as a standard rotation quaternion: given a unit vector along a rotational axis mathbf v and an angle around that axis theta, the quaternion is","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"q = left(cos fractheta2 sin fractheta2 mathbf v right)","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"This quaternion represents a rotation from body-fixed coordinates to world coordinates.","category":"page"},{"location":"#Quick-start-1","page":"QuaternionIntegrator","title":"Quick start","text":"","category":"section"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"using Quaternions, QuaternionIntegrator, LinearAlgebra\n\n# Constant torque around y axis\ntorque(q) = [0.0, 1.0, 0.0]\n\n# Simplest diagonal inertial tensor\nI = diagm([1.0, 1.0, 1.0])\n\n# Starting orientation (no rotation)\nq0 = Quaternion(1.0, 0.0, 0.0, 0.0)\n\n# Starting angular velocity (not rotating)\nω0 = [0.0, 0.0, 0.0]\n\n# Integration time step\n∆t = 0.01\n\n# Get orientation and angular velocity after one timestep\nq1, ω1 = integrate(q0, ω0, I, ∆t, torque)\n\n# Compute 1000 time steps ahead\nqn, ωn = integrate(q0, ω0, I, ∆t, torque, 1000)","category":"page"},{"location":"#Now-supporting-Unitful.jl!-1","page":"QuaternionIntegrator","title":"Now supporting Unitful.jl!","text":"","category":"section"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"If Unitful.jl units are provided for the inputs, the output will have correct units. This has a minor effect on performance.","category":"page"},{"location":"#","page":"QuaternionIntegrator","title":"QuaternionIntegrator","text":"using Quaternions, QuaternionIntegrator, Unitful, LinearAlgebra\n∆t = 10000.0 * u\"µs\"\nI = diagm([1.0, 1.0, 1.0]) * u\"kg * m^2\"\ntorque(q) = [0.0, 1000.0, 0.0] * u\"N * mm\"\nq0 = Quaternion(1.0, 0.0, 0.0, 0.0)\nω0 = [0.0, 0.0, 0.0] * u\"1/s\"\nq1, ω1 = integrate(q0, ω0, I, ∆t, torque, 1000)","category":"page"}]
}
